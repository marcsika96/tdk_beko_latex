\chapter{Gráflekérdezések automatikus generálása}
\section{Lekérdezések generálása}

\subsection{Tesztelni kívánt résznyelv kiválasztása}

A gráfgenerátor egyik bemenete a tesztelni kívánt nyelvi fregmens metamodellje. Ahhoz, hogy hasznos tesztesetek állítsunk elő, szükséges a generátort egy konkrét feladatot ellátó modellek előállítására konfigurálni. (Ha az egész nyelvet használnánk akkor a lekérdezése érdektelen részletekből állna, például kommenteket, felesleges változó átnevezéseket, lekérdezéssel kapcsolatos metainformációkat generálna.) Munkám során tehát az első feladat az volt, hogy kiválasszam a Cyphernek egy olyan résznyelvét amellyel érdekes lekérdezéseket lehet generálni. Dolgozatomban olyan úgynevezett pozitív mintájú lekérdezések generálására koncentráltam, amelyek vizsgálják a csomópontok típusát illetve a csomópontok közötti kapcsolatok típusát. Ugyanis számos lekérdező nyelvben, mint például Cypher\cite{Cypher} és \textsc{VIATRA} \cite{viatra} ezek képezik a lekérdezések alapját. 
 
Alább azt kívánom megmutatni, hogy egy példalekérdezés alapján hogyan szűkítettem le a slizaa \cite{slizaa_2018} nevű Xtext alapú Cypher metamodellt. 

\begin{lstlisting}[style=cyphersmall]
MATCH (train : Train {name : "train1"})-[:ON]->(seg : Segment {name : "seg3"}) 
RETURN seg
\end{lstlisting}

A szűkítést a fenti lekérdezés alapján végeztem a következő metódussal:
\begin{itemize}
	\item Felírtam a fenti lekérdezést a query editorban.
	\item Kibontottam Xtext segítségével.
	\item Megnyitottam a nyelvtan metamodelljét.
	\item A konfigurációs fájlban egy metamodell deklarációs mappába összegyűjtöttem a kibontott fában található osztályokat.
	\item A nyelvtan alapján kiválogattam az osztályok ősosztályait, illetve a használt/használható asszociációkat.
	\item A nyelvtanban ezen kívül növeltem a muptiplicitását legalább 1-re azoknak az elemeknek amelyek generálása elengedhetetlen az értelmes lekérdezések létrejöttéhez.
 	
\end{itemize}   


\subsection{Jólformáltsági kényszerek betartása}
A gráfgenerátor másik bemenete olyan kényszerek halmaza, amelyek szükségesek ahhoz, hogy értelmes modelleket tudjunk generálni. Ezekre főleg azért van szükség, mert az Xtext-ben \cite{xText} íródott nyelvtan és a nyelvtan metamodellje közötti konverzió nem tökéletes. Ennek több oka is van: (1) A precíz metamodell meghatározása számításilag komoly kihívást jelent és nem is végezték el a keretrendszer megalkotói, (2) A metamodellnek hibás modellek leírására is alkalmasnak kell lennie (hiszen szerkesztés közben általában félkész modellek vannak a rendszerben) (3) A metamodell a modelleknek csak atz alap struktúráját (referencia hova mutathat) írja le bonyolultabb szabályok (összetett logikai kifejezések) meghatározására alkalmatlan.

Jólformálsági kényszerekre azért van szükség, mert nem minden a metamodellel leírható modell sorosítható Cypher nyelvű lekérdezéssé. Az Xtext Cypher nyelvtanban leírt parseolhatósági szabályokat át kell fordítani ASG-n értelmezett struktúrális kényszerekké. 




\begin{lstlisting}[style=viatrasmall]
pattern hasReference(retI : ReturnItem, variRef : Expression){
	VariableRef(variRef);
	ReturnItem.expression(retI, variRef);
}

@Constraint(severity ="error", key={ri}, message = "error")
pattern hasNoReference(ri : ReturnItem){
	neg find hasReference(ri, _);
}
\end{lstlisting}

A fenti kényszerre azért volt szükség, mert a metamodellben nem volt megadva, hogy a \cypherStyle{RETURN} szó után kötelező legalább egy változóra referálni is. Pedig ha nem referálnánk itt változót a \cypherStyle{MATCH} ágon megfogalmazott mintából, akkor nem lenne értelme a minta megírásának, illetve a válasznak sem.

A felső minta meghatározza hogy hogyan néz ki egy olyan \viatraStyle{ReturnItem} aminek van \viatraStyle{VariableRef} a visszatérési értékében. Az alsó pedig egy kényszer, ami arra kényszeríti a generátort hogy eldobja az összes olyan modellt, amiben nem találja meg a felső mintát.

\begin{lstlisting}[style=viatrasmall]
pattern wellLookingPattern (patt : Pattern, patternElement : PatternElement){
	Pattern.patterns(patt,patternElement);
}
@Constraint 
pattern notWellLookingPattern(patt : Pattern){
	neg find wellLookingPattern(patt , _);
}
\end{lstlisting}

A fenti kényszerre azért volt szükség, mert a metamodell alapján egy \viatraStyle{Pattern}-be a \viatraStyle{.patterns} tulajdonság beállításakor sok féle elem kerülhetett volna, viszont sok akár a mostaninál bonyolultabb példalekérdezés során sem volt precedens arra, hogy nem \viatraStyle{PatternElement} -ek kerültek bele. Ezért úgy döntöttem, hogy a konzisztensebb és gyorsabb generálás érdekében megtiltom a generátornak, hogy jóként fogadjon el más megoldást.


\begin{lstlisting}[style=viatrasmall]
@Constraint
pattern  patternElementHasVar(pE : PatternElement, vari: VariableDeclaration){
	PatternElement.^var(pE,vari);
}

@Constraint
pattern  patternElementHasPart(pE : PatternElement, pp : PatternPart){
	PatternElement.part(pE,pp);
}
\end{lstlisting}
 A fenti két kényszerre azért volt szükség, mert a \viatraStyle{PatternElement} osztály örököl a \viatraStyle{PatternPart} osztálytól egy \viatraStyle{var} és egy \viatraStyle{part} tulajdonságot, pedig ilyen tulajdonságokkal nem szabadna rendelkeznie, csak ez az információ elveszett a Cypher Xtext nyelvtanának metamodellé generálódása során. Ezért hibásnak nyilvánítom azokat a \viatraStyle{PatternElement}-eket, amelyek rendel a két tulajdonság valamelyikével. 


\begin{lstlisting}[style=viatrasmall]
pattern pe(pe:PatternElement) {
	PatternElement(pe);
}

@Constraint
pattern notPatternElement( pp : PatternPart){
	neg find pe(pp);
}
\end{lstlisting}

A munkám során vizsgált példalekérdezések között nem volt olyan \viatraStyle{PatternPart}, ami nem volt \viatraStyle{PatternElement}. Viszont a generátor számára meghatározott metamodellben mindkét osztály szerepel, és egyik sem absztrakt, így a generátor sokat bajlódna \viatraStyle{PatternPart}-ok generálásával, ezzel fontos időt veszítve. Ettől a lehetőségtől a fenti kényszer segítségével megfosztom.     

\begin{lstlisting}[style=viatrasmall]
@Constraint
pattern notWellLookingMapliteral(mapLiteral : MapLiteral, nodeLabel: NodeLabel){
	MapLiteral.nodeLabels(mapLiteral,nodeLabel);
}

\end{lstlisting}

A \viatraStyle{Mapliteral} osztály örököl egy \viatraStyle{nodelabels} tulajdonságot, és ezáltal nyelvtanilag helytelenné válik, mivel a \viatraStyle{Mapliteral}-ok a következőképpen néznek  ki a Cypher nyelven: \cypherStyle{name : "seg3"} és egyéb elemek nem kerülhetnek bele. 

\begin{lstlisting}[style=viatrasmall]
pattern wellDeepMap(mapLiteralEnrty: MapLiteralEntry, string : StringLiteral){
	MapLiteralEntry.value(mapLiteralEnrty,string);
}

@Constraint
pattern notWellDeepMap(mapLiteralEnrty : MapLiteralEntry){
	neg find wellDeepMap(mapLiteralEnrty, _);
}
\end{lstlisting}

Erre a mintára pedig azért van szükség, mert ha nem lennének akkor a következőhöz hasonló értelmetlen lekérdezések generálása válna lehetővé:

\begin{lstlisting}[style=cyphersmall]
MATCH (seg : Segment {name : {name2 : {name3: { name4 : seg4}}}}) 
RETURN seg
\end{lstlisting}

És a generátor nagy méretű modelleknél könnyen esne abba a hibába hogy az extra csúcspontokat így pocsékolja el.




\subsection{Diverzitás biztosítása}
pár mondat




\section{Post processing}
Az előző fejezetben kifejtettem miért jó  a változókat csak utólag elnevezni. Ezt a feladatrészt az utófeldolgozás során végzem el. Itt adom hozzá ezen kívül azokat a részleteket is a modellekhez, ami mindegyikben azonos, ezért a generálás során nem foglalkoztam vele. Ahhoz, hogy értelmesen nevezzem el az egyes változókat, a Train Benchmark metamodelljére építettem, ami látható \aref{fig:trainbenchmarkfig2}. ábrán.

Három féle elemet kell elneveznünk a jelenleg generált modellekben. (1) csomópont címkék \viatraStyle{NodeLabel.labelName} , (2) kapcsolat címkék \viatraStyle{RelationshipDetail.relTypeNames} és (3) tulajdonság címkék \viatraStyle{MapLiteralEntry.key}.
Ezek mind megfeleltethetőek az ábrán látható elemeknek. A csomópont címkék az osztályok neveinek, a kapcsolat címék az asszociációk neveinek, míg a tulajdonságcímkék az attribútumoknak. Ezért készítettem három listát a megfelelő nevekkel.
\begin{enumerate}
	\item csomópont címkék : Region, Route, Segment, Semaphore, Sensor, Switch, SwitchPosition
	\item kapcsolat címkék : connectsTo, entry, exit, follows, monitoredBy, monitors,
	"requires", "target"
	\item tulajdonság címkék : id, active, position, currentPosition, length, signal
	
\end{enumerate}
Ezután szükségem volt egy randomizáló függvényre, amely a megfelelő nevek valamelyikét elhelyezi egy-egy elemen.
Majd bekötöttem mindhárom típus minden elemére a megfelelő szavakat.

Ezen kívül a lekérdezésekben vannak még változók is amelyeket szisztematikusan elneveztem V1...Vn-el, illetve literálok amiket pedig "String1"..."Stringn"-el neveztem el. 










\section{Fordítás}
itt egy összefoglaló pár mondatban, ha esetleg valaki kihagyta volna az előző fejezetet, hogy mit jelent az alcím.

kód

hogy olvasok be

kód

hogy itarok ki

kód

nyelvtan ami alapján dolgozok

lekérdezés

ilyen a végtermék

