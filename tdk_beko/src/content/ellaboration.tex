\chapter{Gráflekérdezések automatikus generálása}
\section{Lekérdezések generálása}

\subsection{Tesztelni kívánt résznyelv kiválasztása}

A gráfgenerátor egyik bemenete a tesztelni kívánt nyelvi fregmens metamodellje. Ahhoz, hogy hasznos tesztesetek állítsunk elő, szükséges a generátort egy konkrét feladatot ellátó modellek előállítására konfigurálni. (Ha az egész nyelvet használnánk akkor a lekérdezése érdektelen részletekből állna, például kommenteket, felesleges változó átnevezéseket, lekérdezéssel kapcsolatos metainformációkat generálna.) Munkám során tehát az első feladat az volt, hogy kiválasszam a Cyphernek egy olyan résznyelvét amellyel érdekes lekérdezéseket lehet generálni. Dolgozatomban olyan úgynevezett pozitív mintájú lekérdezések generálására koncentráltam, amelyek vizsgálják a csomópontok típusát illetve a csomópontok közötti kapcsolatok típusát. Ugyanis számos lekérdező nyelvben, mint például Cypher\cite{Cypher} és \textsc{VIATRA} \cite{viatra} ezek képezik a lekérdezések alapját. 
 
Alább azt kívánom megmutatni, hogy egy példalekérdezés alapján hogyan szűkítettem le a slizaa \cite{slizaa_2018} nevű Xtext alapú Cypher metamodellt. 

\begin{lstlisting}[style=cyphersmall]
MATCH (train : Train {name : "train1"})-[:ON]->(seg : Segment {name : "seg3"}) 
RETURN seg
\end{lstlisting}

A szűkítést a fenti lekérdezés alapján végeztem a következő metódussal:
\begin{itemize}
	\item Felírtam a fenti lekérdezést a query editorban.
	\item Kibontottam Xtext segítségével.
	\item Megnyitottam a nyelvtan metamodelljét.
	\item A konfigurációs fájlban egy metamodell deklarációs mappába összegyűjtöttem a kibontott fában található osztályokat.
	\item A nyelvtan alapján kiválogattam az osztályok ősosztályait, illetve a használt/használható asszociációkat.
	\item A nyelvtanban ezen kívül növeltem a muptiplicitását legalább 1-re azoknak az elemeknek amelyek generálása elengedhetetlen az értelmes lekérdezések létrejöttéhez.
 	
\end{itemize}   


\subsection{Jólformáltsági kényszerek betartása}
A gráfgenerátor másik bemenete olyan kényszerek halmaza, amelyek szükségesek ahhoz, hogy értelmes modelleket tudjunk generálni. Ezekre főleg azért van szükség, mert az Xtext-ben \cite{xText} íródott nyelvtan és a nyelvtan metamodellje közötti konverzió nem tökéletes. Ennek több oka is van: (1) A precíz metamodell meghatározása számításilag komoly kihívást jelent és nem is végezték el a keretrendszer megalkotói, (2) A metamodellnek hibás modellek leírására is alkalmasnak kell lennie (hiszen szerkesztés közben általában félkész modellek vannak a rendszerben) (3) A metamodell a modelleknek csak atz alap struktúráját (referencia hova mutathat) írja le bonyolultabb szabályok (összetett logikai kifejezések) meghatározására alkalmatlan.

Jólformálsági kényszerekre azért van szükség, mert nem minden a metamodellel leírható modell sorosítható Cypher nyelvű lekérdezéssé. Az Xtext Cypher nyelvtanban leírt parseolhatósági szabályokat át kell fordítani ASG-n értelmezett struktúrális kényszerekké. 




\begin{lstlisting}[style=viatrasmall]
pattern hasReference(retI : ReturnItem, variRef : Expression){
VariableRef(variRef);
ReturnItem.expression(retI, variRef);
}

@Constraint(severity ="error", key={ri}, message = "error")
pattern hasNoReference(ri : ReturnItem){
neg find hasReference(ri, _);
}
\end{lstlisting}

A fenti kényszerre azért volt szükség, mert a metamodellben nem volt megadva, hogy a \cypherStyle{RETURN} szó után kötelező legalább egy változóra referálni is. Pedig ha nem referálnánk itt változót a \cypherStyle{MATCH} ágon megfogalmazott mintából, akkor nem lenne értelme a minta megírásának, illetve a válasznak sem.

A felső minta meghatározza hogy hogyan néz ki egy olyan \viatraStyle{ReturnItem} aminek van \viatraStyle{VariableRef} a visszatérési értékében. Az alsó pedig egy kényszer, ami arra kényszeríti a generátort hogy eldobja az összes olyan modellt, amiben nem találja meg a felső mintát.

\begin{lstlisting}[style=viatrasmall]
pattern wellLookingPattern (^pattern : Pattern, patternElement : PatternElement){
Pattern.patterns(^pattern,patternElement);
}
@Constraint pattern notWellLookingPattern(^pattern : Pattern){
neg find wellLookingPattern(^pattern , _);
}
\end{lstlisting}

A fenti kényszerre azért volt szükség, mert a metamodell alapján egy \viatraStyle{Pattern}-be a \viatraStyle{.patterns} tulajdonság beállításakor sok féle elem kerülhetett volna, viszont sok akár a mostaninál bonyolultabb példalekérdezés során sem volt precedens arra, hogy nem \viatraStyle{PatternElement} -ek kerültek bele. Ezért úgy döntöttem, hogy a konzisztensebb és gyorsabb generálás érdekében megtiltom a generátornak, hogy jóként fogadjon el más megoldást.

\begin{lstlisting}[style=viatrasmall]
pattern wellLookingPatternElement(patternElement : PatternElement, nodePattern : NodePattern){
PatternElement.nodepattern(patternElement, nodePattern);
}

@Constraint pattern notWellLookingPatternElement(patternElement : PatternElement){
neg find wellLookingPatternElement(patternElement, _);
}
\end{lstlisting}


\begin{lstlisting}[style=viatrasmall]
@Constraint(severity ="error", key={patternElement}, message = "error")
pattern  patternElementHasVar(patternElement : PatternElement, variable : VariableDeclaration){
PatternElement.^var(patternElement,variable);
}

@Constraint(severity ="error", key={patternElement}, message = "error")
pattern  patternElementHasPart(patternElement : PatternElement, part : PatternPart){
PatternElement.part(patternElement,part);
}
\end{lstlisting}

\begin{lstlisting}[style=viatrasmall]
pattern pe(pe:PatternElement) {
PatternElement(pe);
}

@Constraint(severity ="error", key={patternPart}, message = "error")
pattern notPatternElement( patternPart : PatternPart){
neg find pe(patternPart);
}
\end{lstlisting}

\begin{lstlisting}[style=viatrasmall]
@Constraint(severity ="error", key={mapLiteral}, message = "error")
pattern notWellLookingMapliteral(mapLiteral : MapLiteral, nodeLabel: NodeLabel){
MapLiteral.nodeLabels(mapLiteral,nodeLabel);
}

\end{lstlisting}

\begin{lstlisting}[style=viatrasmall]
//ahhoz kell hogy ne ott legyene különböző 2 lekédrezés hogy milyen méllyen cíkmkézett
pattern wellDeepMap(mapLiteralEnrty: MapLiteralEntry, string : StringLiteral){
MapLiteralEntry.value(mapLiteralEnrty,string);
}

@Constraint(severity ="error", key={mapLiteralEnrty}, message = "error")
pattern notWellDeepMap(mapLiteralEnrty : MapLiteralEntry){
neg find wellDeepMap(mapLiteralEnrty, _);
}
\end{lstlisting}


A fenti két kényszer azt biztosítja, hogy a lekérdezésnek, amit generálunk mindenképpen meglegyen a két fő része. A match részben határozzuk meg azt a bizonyos mintát, amit keresünk, a return részben pedig visszatérünk az erre a mintára illeszkedő gráfrészletekkel.

Ezen belül ki kell kössük szintén, hogy a két fő rész ne csak csonkként vagy helytelenül generálódjon, hanem az egész elengedhetetlen részfa megszülessen.

Ezért van szükség a return ágon az alábbi kényszerekre:



\subsection{Diverzitás biztosítása}
pár mondat




\section{Post processing}
itt egy összefoglaló pár mondatban, ha esetleg valaki kihagyta volna az előző fejezetet, hogy mit jelent az alcím.

esettanulmány címkehalmaz megadása 

hogy mondom meg mi hova kerülhet

mi alapján tettem azokat ide amiket


\section{Fordítás}
itt egy összefoglaló pár mondatban, ha esetleg valaki kihagyta volna az előző fejezetet, hogy mit jelent az alcím.

kód

hogy olvasok be

kód

hogy itarok ki

kód

nyelvtan ami alapján dolgozok

lekérdezés

ilyen a végtermék

