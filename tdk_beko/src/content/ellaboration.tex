\chapter{Gráflekérdezések automatikus generálása}
\section{Lekérdezések generálása}

\subsection{Tesztelni kívánt résznyelv kiválasztása}

A gráfgenerátor egyik bemenete a tesztelni kívánt nyelvi fregmens metamodellje. Ahhoz, hogy hasznos tesztesetek állítsunk elő, szükséges a generátort egy konkrét feladatot ellátó modellek előállítására konfigurálni. (Ha az egész nyelvet használnánk akkor a lekérdezése érdektelen részletekből állna, például kommenteket, felesleges változó átnevezéseket, lekérdezéssel kapcsolatos metainformációkat generálna.) Munkám során tehát az első feladat az volt, hogy kiválasszam a Cyphernek egy olyan résznyelvét amellyel érdekes lekérdezéseket lehet generálni. Dolgozatomban olyan úgynevezett pozitív mintájú lekérdezések generálására koncentráltam, amelyek vizsgálják a csomópontok típusát illetve a csomópontok közötti kapcsolatok típusát. Ugyanis számos lekérdező nyelvben, mint például Cypher\cite{Cypher} és \textsc{VIATRA} \cite{viatra} ezek képezik a lekérdezések alapját. 
 
Alább azt kívánom megmutatni, hogy egy példalekérdezés alapján hogyan szűkítettem le a slizaa \cite{slizaa_2018} nevű Xtext alapú Cypher metamodellt. 

\begin{lstlisting}[style=cyphersmall]
MATCH (train : Train {name : "train1"})-[:ON]->(seg : Segment {name : "seg3"}) 
RETURN seg
\end{lstlisting}

A szűkítést a fenti lekérdezés alapján végeztem a következő metódussal:
\begin{itemize}
	\item Felírtam a fenti lekérdezést a query editorban.
	\item Kibontottam Xtext segítségével.
	\item Megnyitottam a nyelvtan metamodelljét.
	\item A konfigurációs fájlban egy metamodell deklarációs mappába összegyűjtöttem a kibontott fában található osztályokat.
	\item A nyelvtan alapján kiválogattam az osztályok ősosztályait, illetve a használt/használható asszociációkat.
	\item A nyelvtanban ezen kívül növeltem a muptiplicitását legalább 1-re azoknak az elemeknek amelyek generálása elengedhetetlen az értelmes lekérdezések létrejöttéhez.
 	
\end{itemize}   


\subsection{Jólformáltsági kényszerek betartása}
itt egy összefoglaló pár mondatban, ha esetleg valaki kihagyta volna az előző fejezetet, hogy mit jelent az alcím. pl az alábbi:

Ahhoz, hogy a nyelvtan alapján olyan modelleket tudjunk generálni, amelyeket vissza tudunk majd fordítani szintaktikailag helyes lekérdezésekre, ahhoz kényszereket kell felállítanunk, amelyek betartására kötelezzük a modellgenerátort.

itt pedig a szerintem fontos kényszer

magyarázat

szerintem fontos kényszer

magyarázat

...



Én a következő kényszereket írtam fel:
\viatraStyle{pattern x(s:State)  {State(s);}}, ahol a \viatraStyle{s} változó jelöli a\ldots

\begin{lstlisting}[style=viatrasmall]
pattern goodReferenceToVariable(q : SinglePartQuery, match : Match, vari : VariableDeclaration,  variRef : VariableRef ){	
	SinglePartQuery.readingClauses(q ,match);
	Match.^pattern.patterns.^var(match, vari);
	SinglePartQuery.^return.body.returnItems.items.expression(q , variRef);
	VariableRef.variableRef(variRef, vari);
}	

@Constraint(severity = "error", key ={variRef}, message ="error")
pattern notGoodReferenceToVari(variRef : VariableRef){
	neg find goodReferenceToVariable(_, _, vari ,variRef );
	VariableRef.variableRef(variRef,vari);
}

\end{lstlisting}


A fenti két kényszer azt biztosítja, hogy a lekérdezésnek, amit generálunk mindenképpen meglegyen a két fő része. A match részben határozzuk meg azt a bizonyos mintát, amit keresünk, a return részben pedig visszatérünk az erre a mintára illeszkedő gráfrészletekkel.

Ezen belül ki kell kössük szintén, hogy a két fő rész ne csak csonkként vagy helytelenül generálódjon, hanem az egész elengedhetetlen részfa megszülessen.

Ezért van szükség a return ágon az alábbi kényszerekre:



\subsection{Diverzitás biztosítása}
pár mondat




\section{Post processing}
itt egy összefoglaló pár mondatban, ha esetleg valaki kihagyta volna az előző fejezetet, hogy mit jelent az alcím.

esettanulmány címkehalmaz megadása 

hogy mondom meg mi hova kerülhet

mi alapján tettem azokat ide amiket


\section{Fordítás}
itt egy összefoglaló pár mondatban, ha esetleg valaki kihagyta volna az előző fejezetet, hogy mit jelent az alcím.

kód

hogy olvasok be

kód

hogy itarok ki

kód

nyelvtan ami alapján dolgozok

lekérdezés

ilyen a végtermék

